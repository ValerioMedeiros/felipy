import { useEffect } from "preact/hooks"

declare const Sk: any

export function getCodeRunner(
  setLoading: (loaded: boolean) => void,
  setCodeRunning: (running: boolean) => void,
  onError: (error: string) => void
) {
  useEffect(() => {
    ;(async () => {
      await import("/src/lib/skulpt/skulpt.min.js")
      await import("/src/lib/skulpt/skulpt-stdlib.js")

      function builtinRead(x: string) {
        if (!Sk.builtinFiles.files[x] === undefined) {
          throw new Error(`File not found: "${x}"`)
        }
        return Sk.builtinFiles.files[x]
      }

      Sk.pre = "output"
      Sk.configure({ output: console.log, read: builtinRead })
      ;(Sk.TurtleGraphics || (Sk.TurtleGraphics = {})).target = "turtle"

      Sk.builtins.cos = function (radians: number) {
        return Math.cos(radians)
      }

      Sk.builtins.sin = function (radians: number) {
        return Math.sin(radians)
      }

      Sk.builtinFiles.files = {
        ...Sk.builtinFiles.files,
        ...{
          "./utils.py":
            '"""Utilities\n"""\n# pylint: disable=no-member\n\n\n\ndef floor(value, size, offset=200):\n    """Floor of `value` given `size` and `offset`.\n\n    The floor function is best understood with a diagram of the number line::\n\n         -200  -100    0    100   200\n        <--|--x--|-----|--y--|--z--|-->\n\n    The number line shown has offset 200 denoted by the left-hand tick mark at\n    -200 and size 100 denoted by the tick marks at -100, 0, 100, and 200. The\n    floor of a value is the left-hand tick mark of the range where it lies. So\n    for the points show above: ``floor(x)`` is -200, ``floor(y)`` is 0, and\n    ``floor(z)`` is 100.\n\n    >>> floor(10, 100)\n    0.0\n    >>> floor(120, 100)\n    100.0\n    >>> floor(-10, 100)\n    -100.0\n    >>> floor(-150, 100)\n    -200.0\n    >>> floor(50, 167)\n    -33.0\n\n    """\n    return float(((value + offset) // size) * size - offset)\n\n\ndef path(filename):\n return ""\n\n\ndef line(a, b, x, y):\n    """Draw line from `(a, b)` to `(x, y)`."""\n    import turtle\n\n    turtle.up()\n    turtle.goto(a, b)\n    turtle.down()\n    turtle.goto(x, y)\n\n\ndef square(x, y, size, name):\n    """Draw square at `(x, y)` with side length `size` and fill color `name`.\n\n    The square is oriented so the bottom left corner is at (x, y).\n\n    """\n    import turtle\n\n    turtle.up()\n    turtle.goto(x, y)\n    turtle.down()\n    turtle.color(name)\n    turtle.begin_fill()\n\n    for count in range(4):\n        turtle.forward(size)\n        turtle.left(90)\n\n    turtle.end_fill()\n\n\nclass vector:\n    """Two-dimensional vector.\n\n    Vectors can be modified in-place.\n\n    >>> v = vector(0, 1)\n    >>> v.move(1)\n    >>> v\n    vector(1, 2)\n    >>> v.rotate(90)\n    >>> v\n    vector(-2.0, 1.0)\n\n    """\n\n    # pylint: disable=invalid-name\n    PRECISION = 6\n\n    __slots__ = (\'_x\', \'_y\', \'_hash\')\n\n    def __init__(self, x, y):\n        """Initialize vector with coordinates: x, y.\n\n        >>> v = vector(1, 2)\n        >>> v.x\n        1\n        >>> v.y\n        2\n\n        """\n        self._hash = None\n        self._x = round(x, self.PRECISION)\n        self._y = round(y, self.PRECISION)\n\n    @property\n    def x(self):\n        """X-axis component of vector.\n\n        >>> v = vector(1, 2)\n        >>> v.x\n        1\n        >>> v.x = 3\n        >>> v.x\n        3\n\n        """\n        return self._x\n\n    @x.setter\n    def x(self, value):\n        if self._hash is not None:\n            raise ValueError(\'cannot set x after hashing\')\n        self._x = round(value, self.PRECISION)\n\n    @property\n    def y(self):\n        """Y-axis component of vector.\n\n        >>> v = vector(1, 2)\n        >>> v.y\n        2\n        >>> v.y = 5\n        >>> v.y\n        5\n\n        """\n        return self._y\n\n    @y.setter\n    def y(self, value):\n        if self._hash is not None:\n            raise ValueError(\'cannot set y after hashing\')\n        self._y = round(value, self.PRECISION)\n\n    def __hash__(self):\n        """v.__hash__() -> hash(v)\n\n        >>> v = vector(1, 2)\n        >>> h = hash(v)\n        >>> v.x = 2\n        Traceback (most recent call last):\n            ...\n        ValueError: cannot set x after hashing\n\n        """\n        if self._hash is None:\n            pair = (self.x, self.y)\n            self._hash = hash(pair)\n        return self._hash\n\n    def __len__(self):\n        """v.__len__() -> len(v)\n\n        >>> v = vector(1, 2)\n        >>> len(v)\n        2\n\n        """\n        return 2\n\n    def __getitem__(self, index):\n        """v.__getitem__(v, i) -> v[i]\n\n        >>> v = vector(3, 4)\n        >>> v[0]\n        3\n        >>> v[1]\n        4\n        >>> v[2]\n        Traceback (most recent call last):\n            ...\n        IndexError\n\n        """\n        if index == 0:\n            return self.x\n        if index == 1:\n            return self.y\n        raise IndexError\n\n    def copy(self):\n        """Return copy of vector.\n\n        >>> v = vector(1, 2)\n        >>> w = v.copy()\n        >>> v is w\n        False\n\n        """\n        type_self = type(self)\n        return type_self(self.x, self.y)\n\n    def __eq__(self, other):\n        """v.__eq__(w) -> v == w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(1, 2)\n        >>> v == w\n        True\n\n        """\n        if isinstance(other, vector):\n            return self.x == other.x and self.y == other.y\n        return NotImplemented\n\n    def __ne__(self, other):\n        """v.__ne__(w) -> v != w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v != w\n        True\n\n        """\n        if isinstance(other, vector):\n            return self.x != other.x or self.y != other.y\n        return NotImplemented\n\n    def __iadd__(self, other):\n        """v.__iadd__(w) -> v += w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v += w\n        >>> v\n        vector(4, 6)\n        >>> v += 1\n        >>> v\n        vector(5, 7)\n\n        """\n        if self._hash is not None:\n            raise ValueError(\'cannot add vector after hashing\')\n        if isinstance(other, vector):\n            self.x += other.x\n            self.y += other.y\n        else:\n            self.x += other\n            self.y += other\n        return self\n\n    def __add__(self, other):\n        """v.__add__(w) -> v + w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v + w\n        vector(4, 6)\n        >>> v + 1\n        vector(2, 3)\n        >>> 2.0 + v\n        vector(3.0, 4.0)\n\n        """\n        copy = self.copy()\n        return copy.__iadd__(other)\n\n    __radd__ = __add__\n\n    def move(self, other):\n        """Move vector by other (in-place).\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v.move(w)\n        >>> v\n        vector(4, 6)\n        >>> v.move(3)\n        >>> v\n        vector(7, 9)\n\n        """\n        self.__iadd__(other)\n\n    def __isub__(self, other):\n        """v.__isub__(w) -> v -= w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v -= w\n        >>> v\n        vector(-2, -2)\n        >>> v -= 1\n        >>> v\n        vector(-3, -3)\n\n        """\n        if self._hash is not None:\n            raise ValueError(\'cannot subtract vector after hashing\')\n        if isinstance(other, vector):\n            self.x -= other.x\n            self.y -= other.y\n        else:\n            self.x -= other\n            self.y -= other\n        return self\n\n    def __sub__(self, other):\n        """v.__sub__(w) -> v - w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v - w\n        vector(-2, -2)\n        >>> v - 1\n        vector(0, 1)\n\n        """\n        copy = self.copy()\n        return copy.__isub__(other)\n\n    def __imul__(self, other):\n        """v.__imul__(w) -> v *= w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v *= w\n        >>> v\n        vector(3, 8)\n        >>> v *= 2\n        >>> v\n        vector(6, 16)\n\n        """\n        if self._hash is not None:\n            raise ValueError(\'cannot multiply vector after hashing\')\n        if isinstance(other, vector):\n            self.x *= other.x\n            self.y *= other.y\n        else:\n            self.x *= other\n            self.y *= other\n        return self\n\n    def __mul__(self, other):\n        """v.__mul__(w) -> v * w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v * w\n        vector(3, 8)\n        >>> v * 2\n        vector(2, 4)\n        >>> 3.0 * v\n        vector(3.0, 6.0)\n\n        """\n        copy = self.copy()\n        return copy.__imul__(other)\n\n    __rmul__ = __mul__\n\n    def scale(self, other):\n        """Scale vector by other (in-place).\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> v.scale(w)\n        >>> v\n        vector(3, 8)\n        >>> v.scale(0.5)\n        >>> v\n        vector(1.5, 4.0)\n\n        """\n        self.__imul__(other)\n\n    def __itruediv__(self, other):\n        """v.__itruediv__(w) -> v /= w\n\n        >>> v = vector(2, 4)\n        >>> w = vector(4, 8)\n        >>> v /= w\n        >>> v\n        vector(0.5, 0.5)\n        >>> v /= 2\n        >>> v\n        vector(0.25, 0.25)\n\n        """\n        if self._hash is not None:\n            raise ValueError(\'cannot divide vector after hashing\')\n        if isinstance(other, vector):\n            self.x /= other.x\n            self.y /= other.y\n        else:\n            self.x /= other\n            self.y /= other\n        return self\n\n    def __truediv__(self, other):\n        """v.__truediv__(w) -> v / w\n\n        >>> v = vector(1, 2)\n        >>> w = vector(3, 4)\n        >>> w / v\n        vector(3.0, 2.0)\n        >>> v / 2\n        vector(0.5, 1.0)\n\n        """\n        copy = self.copy()\n        return copy.__itruediv__(other)\n\n    def __neg__(self):\n        """v.__neg__() -> -v\n\n        >>> v = vector(1, 2)\n        >>> -v\n        vector(-1, -2)\n\n        """\n        # pylint: disable=invalid-unary-operand-type\n        copy = self.copy()\n        copy.x = -copy.x\n        copy.y = -copy.y\n        return copy\n\n    def __abs__(self):\n        """v.__abs__() -> abs(v)\n\n        >>> v = vector(3, 4)\n        >>> abs(v)\n        5.0\n\n        """\n        return (self.x ** 2 + self.y ** 2) ** 0.5\n\n    def rotate(self, angle):\n        """Rotate vector counter-clockwise by angle (in-place).\n\n        >>> v = vector(1, 2)\n        >>> v.rotate(90)\n        >>> v == vector(-2, 1)\n        True\n\n        """\n        if self._hash is not None:\n            raise ValueError(\'cannot rotate vector after hashing\')\n        radians = angle * 3.141592653589793 / 180.0\n        cosine = cos(radians)\n        sine = sin(radians)\n        x = self.x\n        y = self.y\n        self.x = x * cosine - y * sine\n        self.y = y * cosine + x * sine\n\n    def __repr__(self):\n        """v.__repr__() -> repr(v)\n\n        >>> v = vector(1, 2)\n        >>> repr(v)\n        \'vector(1, 2)\'\n\n        """\n        type_self = type(self)\n        name = type_self.__name__\n        return \'{}({!r}, {!r})\'.format(name, self.x, self.y)\n',
          "./paint.py":
            "\"\"\"Paint, for drawing shapes.\n\nExercises\n\n1. Add a color.\n2. Complete circle.\n3. Complete rectangle.\n4. Complete triangle.\n5. Add width parameter.\n\"\"\"\n\nfrom turtle import *\n\nfrom freegames import vector\n\n\ndef line(start, end):\n    \"\"\"Draw line from start to end.\"\"\"\n    up()\n    goto(start.x, start.y)\n    down()\n    goto(end.x, end.y)\n\n\ndef square(start, end):\n    \"\"\"Draw square from start to end.\"\"\"\n    up()\n    goto(start.x, start.y)\n    down()\n    begin_fill()\n\n    for count in range(4):\n        forward(end.x - start.x)\n        left(90)\n\n    end_fill()\n\n\ndef circle(start, end):\n    \"\"\"Draw circle from start to end.\"\"\"\n    pass  # TODO\n\n\ndef rectangle(start, end):\n    \"\"\"Draw rectangle from start to end.\"\"\"\n    pass  # TODO\n\n\ndef triangle(start, end):\n    \"\"\"Draw triangle from start to end.\"\"\"\n    pass  # TODO\n\n\ndef tap(x, y):\n    \"\"\"Store starting point or draw shape.\"\"\"\n    start = state['start']\n\n    if start is None:\n        state['start'] = vector(x, y)\n    else:\n        shape = state['shape']\n        end = vector(x, y)\n        shape(start, end)\n        state['start'] = None\n\n\ndef store(key, value):\n    \"\"\"Store value in state at key.\"\"\"\n    state[key] = value\n\n\nstate = {'start': None, 'shape': line}\nsetup(420, 420, 370, 0)\nonscreenclick(tap)\nlisten()\nonkey(undo, 'u')\nonkey(lambda: color('black'), 'K')\nonkey(lambda: color('white'), 'W')\nonkey(lambda: color('green'), 'G')\nonkey(lambda: color('blue'), 'B')\nonkey(lambda: color('red'), 'R')\nonkey(lambda: store('shape', line), 'l')\nonkey(lambda: store('shape', square), 's')\nonkey(lambda: store('shape', circle), 'c')\nonkey(lambda: store('shape', rectangle), 'r')\nonkey(lambda: store('shape', triangle), 't')\ndone()\n",
          "./simonsays.py":
            '"""Simon Says\n\nExercises\n\n1. Speed up tile flash rate.\n2. Add more tiles.\n"""\n\nfrom random import choice\nfrom time import sleep\nfrom turtle import *\n\nfrom freegames import floor, square, vector\n\npattern = []\nguesses = []\ntiles = {\n    vector(0, 0): (\'red\', \'dark red\'),\n    vector(0, -200): (\'blue\', \'dark blue\'),\n    vector(-200, 0): (\'green\', \'dark green\'),\n    vector(-200, -200): (\'yellow\', \'khaki\'),\n}\n\n\ndef grid():\n    """Draw grid of tiles."""\n    square(0, 0, 200, \'dark red\')\n    square(0, -200, 200, \'dark blue\')\n    square(-200, 0, 200, \'dark green\')\n    square(-200, -200, 200, \'khaki\')\n    update()\n\n\ndef flash(tile):\n    """Flash tile in grid."""\n    glow, dark = tiles[tile]\n    square(tile.x, tile.y, 200, glow)\n    update()\n    sleep(0.5)\n    square(tile.x, tile.y, 200, dark)\n    update()\n    sleep(0.5)\n\n\ndef grow():\n    """Grow pattern and flash tiles."""\n    tile = choice(list(tiles))\n    pattern.append(tile)\n\n    for tile in pattern:\n        flash(tile)\n\n    print(\'Pattern length:\', len(pattern))\n    guesses.clear()\n\n\ndef tap(x, y):\n    """Respond to screen tap."""\n    onscreenclick(None)\n    x = floor(x, 200)\n    y = floor(y, 200)\n    tile = vector(x, y)\n    index = len(guesses)\n\n    if tile != pattern[index]:\n        exit()\n\n    guesses.append(tile)\n    flash(tile)\n\n    if len(guesses) == len(pattern):\n        grow()\n\n    onscreenclick(tap)\n\n\ndef start(x, y):\n    """Start game."""\n    grow()\n    onscreenclick(tap)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\ngrid()\nonscreenclick(start)\ndone()\n',
          "./tictactoe.py":
            '"""Tic Tac Toe\n\nExercises\n\n1. Give the X and O a different color and width.\n2. What happens when someone taps a taken spot?\n3. How would you detect when someone has won?\n4. How could you create a computer player?\n"""\n\nfrom turtle import *\n\nfrom freegames import line\n\n\ndef grid():\n    """Draw tic-tac-toe grid."""\n    line(-67, 200, -67, -200)\n    line(67, 200, 67, -200)\n    line(-200, -67, 200, -67)\n    line(-200, 67, 200, 67)\n\n\ndef drawx(x, y):\n    """Draw X player."""\n    line(x, y, x + 133, y + 133)\n    line(x, y + 133, x + 133, y)\n\n\ndef drawo(x, y):\n    """Draw O player."""\n    up()\n    goto(x + 67, y + 5)\n    down()\n    circle(62)\n\n\ndef floor(value):\n    """Round value down to grid with square size 133."""\n    return ((value + 200) // 133) * 133 - 200\n\n\nstate = {\'player\': 0}\nplayers = [drawx, drawo]\n\n\ndef tap(x, y):\n    """Draw X or O in tapped square."""\n    x = floor(x)\n    y = floor(y)\n    player = state[\'player\']\n    draw = players[player]\n    draw(x, y)\n    update()\n    state[\'player\'] = not player\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\ngrid()\nupdate()\nonscreenclick(tap)\ndone()\n',
          "./freegames.py":
            "\"\"\"Free Python Games\n\nFree Python Games is an Apache2 licensed collection of free Python games\nintended for education and fun. The games are written in simple Python code and\ndesigned for experimentation and changes. Simplified versions of several\nclassic arcade games are included.\n\nPython is one of the top-five most popular programming languages in the world\nand available for free from www.python.org. Python includes an extensive\nStandard Library distributed with your installation. The Standard Library has a\nmodule called Turtle which is a popular way to introduce programming to\nkids. Turtle was part of the original Logo programming language developed by\nWally Feurzig and Seymour Papert in 1966. All of the games in Free Python Games\nare implemented using Python and its Turtle module.\n\nStarting in 2012, Free Python Games began as an after school program to teach\nprogramming to inner-city youth. The goal was to have fun as much as it was to\nlearn. Since then the games have been improved and used in a variety of\nsettings ranging from classrooms to summer day-camps.\n\nThe games run anywhere Python can be installed which includes desktop computers\nrunning Windows, Mac OS, or Linux and older or low-power hardware such as the\nRaspberry Pi. Kids across the United States in grades 6th-12th have enjoyed\nlearning about topics such as encryption and projectile motion through games.\n\nEach game is entirely independent from the others and includes comments along\nwith a list of exercises to work through with students. Creativity and\nflexibility is important. There is no right or wrong way to implement a new\nfeature or behavior! You never know which games students will engage with best.\n\nFree Python Games supports a command-line interface (CLI). Help for the CLI is\navailable using::\n\n  $ python3 -m freegames --help\n\nThe CLI supports three commands: list, copy, and show. For a list of all games\nrun::\n\n  $ python3 -m freegames list\n\nAny of the listed games may be played by executing the Python module from the\ncommand-line. To reference the Python module, combine \"freegames\" with the name\nof the game. For example, to play the \"snake\" game run::\n\n  $ python3 -m freegames.snake\n\nGames can be modified by copying their source code. The copy command will\ncreate a Python file in your local directory which you can edit. For example,\nto copy and play the \"snake\" game run::\n\n  $ python3 -m freegames copy snake\n  $ python3 snake.py\n\nPython includes a built-in text editor named IDLE which can also execute Python\ncode. To launch the editor and make changes to the \"snake\" game run::\n\n  $ python3 -m idlelib.idle snake.py\n\"\"\"\n\nfrom utils import floor, line, path, square, vector\n\n__all__ = ['floor', 'line', 'path', 'square', 'vector']\n\n__title__ = 'freegames'\n__version__ = '2.4.0'\n__build__ = 0x020400\n__author__ = 'Grant Jenks'\n__license__ = 'Apache 2.0'\n__copyright__ = '2017-2022, Grant Jenks'\n",
          "./pong.py":
            '"""Pong, classic arcade game.\n\nExercises\n\n1. Change the colors.\n2. What is the frame rate? Make it faster or slower.\n3. Change the speed of the ball.\n4. Change the size of the paddles.\n5. Change how the ball bounces off walls.\n6. How would you add a computer player?\n6. Add a second ball.\n"""\n\nfrom random import choice, random\nfrom turtle import *\n\nfrom freegames import vector\n\n\ndef value():\n    """Randomly generate value between (-5, -3) or (3, 5)."""\n    return (3 + random() * 2) * choice([1, -1])\n\n\nball = vector(0, 0)\naim = vector(value(), value())\nstate = {1: 0, 2: 0}\n\n\ndef move(player, change):\n    """Move player position by change."""\n    state[player] += change\n\n\ndef rectangle(x, y, width, height):\n    """Draw rectangle at (x, y) with given width and height."""\n    up()\n    goto(x, y)\n    down()\n    begin_fill()\n    for count in range(2):\n        forward(width)\n        left(90)\n        forward(height)\n        left(90)\n    end_fill()\n\n\ndef draw():\n    """Draw game and move pong ball."""\n    clear()\n    rectangle(-200, state[1], 10, 50)\n    rectangle(190, state[2], 10, 50)\n\n    ball.move(aim)\n    x = ball.x\n    y = ball.y\n\n    up()\n    goto(x, y)\n    dot(10)\n    update()\n\n    if y < -200 or y > 200:\n        aim.y = -aim.y\n\n    if x < -185:\n        low = state[1]\n        high = state[1] + 50\n\n        if low <= y <= high:\n            aim.x = -aim.x\n        else:\n            return\n\n    if x > 185:\n        low = state[2]\n        high = state[2] + 50\n\n        if low <= y <= high:\n            aim.x = -aim.x\n        else:\n            return\n\n    ontimer(draw, 50)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\nlisten()\nonkey(lambda: move(1, 20), \'w\')\nonkey(lambda: move(1, -20), \'s\')\nonkey(lambda: move(2, 20), \'i\')\nonkey(lambda: move(2, -20), \'k\')\ndraw()\ndone()\n',
          "./pacman.py":
            '"""Pacman, classic arcade game.\n\nExercises\n\n1. Change the board.\n2. Change the number of ghosts.\n3. Change where pacman starts.\n4. Make the ghosts faster/slower.\n5. Make the ghosts smarter.\n"""\n\nfrom random import choice\nfrom turtle import *\n\nfrom freegames import floor, vector\n\nstate = {\'score\': 0}\npath = Turtle(visible=False)\nwriter = Turtle(visible=False)\naim = vector(5, 0)\npacman = vector(-40, -80)\nghosts = [\n    [vector(-180, 160), vector(5, 0)],\n    [vector(-180, -160), vector(0, 5)],\n    [vector(100, 160), vector(0, -5)],\n    [vector(100, -160), vector(-5, 0)],\n]\n# fmt: off\ntiles = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\n    0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\n    0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0,\n    0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\n    0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0,\n    0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\n    0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0,\n    0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0,\n    0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n]\n# fmt: on\n\n\ndef square(x, y):\n    """Draw square using path at (x, y)."""\n    path.up()\n    path.goto(x, y)\n    path.down()\n    path.begin_fill()\n\n    for count in range(4):\n        path.forward(20)\n        path.left(90)\n\n    path.end_fill()\n\n\ndef offset(point):\n    """Return offset of point in tiles."""\n    x = (floor(point.x, 20) + 200) / 20\n    y = (180 - floor(point.y, 20)) / 20\n    index = int(x + y * 20)\n    return index\n\n\ndef valid(point):\n    """Return True if point is valid in tiles."""\n    index = offset(point)\n\n    if tiles[index] == 0:\n        return False\n\n    index = offset(point + 19)\n\n    if tiles[index] == 0:\n        return False\n\n    return point.x % 20 == 0 or point.y % 20 == 0\n\n\ndef world():\n    """Draw world using path."""\n    bgcolor(\'black\')\n    path.color(\'blue\')\n\n    for index in range(len(tiles)):\n        tile = tiles[index]\n\n        if tile > 0:\n            x = (index % 20) * 20 - 200\n            y = 180 - (index // 20) * 20\n            square(x, y)\n\n            if tile == 1:\n                path.up()\n                path.goto(x + 10, y + 10)\n                path.dot(2, \'white\')\n\n\ndef move():\n    """Move pacman and all ghosts."""\n    writer.undo()\n    writer.write(state[\'score\'])\n\n    clear()\n\n    if valid(pacman + aim):\n        pacman.move(aim)\n\n    index = offset(pacman)\n\n    if tiles[index] == 1:\n        tiles[index] = 2\n        state[\'score\'] += 1\n        x = (index % 20) * 20 - 200\n        y = 180 - (index // 20) * 20\n        square(x, y)\n\n    up()\n    goto(pacman.x + 10, pacman.y + 10)\n    dot(20, \'yellow\')\n\n    for point, course in ghosts:\n        if valid(point + course):\n            point.move(course)\n        else:\n            options = [\n                vector(5, 0),\n                vector(-5, 0),\n                vector(0, 5),\n                vector(0, -5),\n            ]\n            plan = choice(options)\n            course.x = plan.x\n            course.y = plan.y\n\n        up()\n        goto(point.x + 10, point.y + 10)\n        dot(20, \'red\')\n\n    update()\n\n    for point, course in ghosts:\n        if abs(pacman - point) < 20:\n            return\n\n    ontimer(move, 100)\n\n\ndef change(x, y):\n    """Change pacman aim if valid."""\n    if valid(pacman + vector(x, y)):\n        aim.x = x\n        aim.y = y\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\nwriter.goto(160, 160)\nwriter.color(\'white\')\nwriter.write(state[\'score\'])\nlisten()\nonkey(lambda: change(5, 0), \'Right\')\nonkey(lambda: change(-5, 0), \'Left\')\nonkey(lambda: change(0, 5), \'Up\')\nonkey(lambda: change(0, -5), \'Down\')\nworld()\nmove()\ndone()\n',
          "./madlibs.py":
            "\"\"\"Mad Libs: Funny Story Creation Game\n\nExercises:\n\n1. How to replace the story?\n2. How load the story and from a file?\n3. How to add additional parts of speech?\n\"\"\"\n\n# The quick brown fox jumps over the lazy dog.\ntemplate = 'The |1| |2| |3| |4| over the |5| |6|.'\nparts = {\n    '1': 'adjective',\n    '2': 'adjective',\n    '3': 'noun',\n    '4': 'verb',\n    '5': 'adjective',\n    '6': 'noun',\n}\n\nchunks = []\n\nfor chunk in template.split('|'):\n    if chunk in parts:\n        description = parts[chunk]\n        prompt = 'Enter [{}]: '.format(description)\n        word = input(prompt)\n        chunks.append(word)\n    else:\n        chunks.append(chunk)\n\nprint('=' * 80)\nstory = ''.join(chunks)\nprint(story)\n",
          "./tron.py":
            '"""Tron, classic arcade game.\n\nExercises\n\n1. Make the tron players faster/slower.\n2. Stop a tron player from running into itself.\n3. Allow the tron player to go around the edge of the screen.\n4. How would you create a computer player?\n"""\n\nfrom turtle import *\n\nfrom freegames import square, vector\n\np1xy = vector(-100, 0)\np1aim = vector(4, 0)\np1body = set()\n\np2xy = vector(100, 0)\np2aim = vector(-4, 0)\np2body = set()\n\n\ndef inside(head):\n    """Return True if head inside screen."""\n    return -200 < head.x < 200 and -200 < head.y < 200\n\n\ndef draw():\n    """Advance players and draw game."""\n    p1xy.move(p1aim)\n    p1head = p1xy.copy()\n\n    p2xy.move(p2aim)\n    p2head = p2xy.copy()\n\n    if not inside(p1head) or p1head in p2body:\n        print(\'Player blue wins!\')\n        return\n\n    if not inside(p2head) or p2head in p1body:\n        print(\'Player red wins!\')\n        return\n\n    p1body.add(p1head)\n    p2body.add(p2head)\n\n    square(p1xy.x, p1xy.y, 3, \'red\')\n    square(p2xy.x, p2xy.y, 3, \'blue\')\n    update()\n    ontimer(draw, 50)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\nlisten()\nonkey(lambda: p1aim.rotate(90), \'a\')\nonkey(lambda: p1aim.rotate(-90), \'d\')\nonkey(lambda: p2aim.rotate(90), \'j\')\nonkey(lambda: p2aim.rotate(-90), \'l\')\ndraw()\ndone()\n',
          "./guess.py":
            "\"\"\"Guess a number within a range.\n\nExercises\n\n1. Change the range to be from 0 to 1,000,000.\n2. Can you still guess the number?\n3. Print the number of guesses made.\n4. Limit the number of guesses to the minimum required.\n\"\"\"\n\nfrom random import randint\n\nstart = 1\nend = 100\nvalue = randint(start, end)\n\n# print(value)\nprint(\"I'm thinking of a number between\", start, 'and', end)\n\nguess = None\n\nwhile guess != value:\n    text = input('Guess the number: ')\n    guess = int(text)\n\n    if guess < value:\n        print('Higher.')\n    elif guess > value:\n        print('Lower.')\n\nprint('Congratulations! You guessed the right answer:', value)\n",
          "./life.py":
            '"""Game of Life simulation.\n\nConway\'s game of life is a classic cellular automation created in 1970 by John\nConway. https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life\n\nExercises\n\n1. Can you identify any Still Lifes, Oscillators, or Spaceships?\n2. How can you make the simulation faster? Or bigger?\n3. How would you modify the initial state?\n4. Try changing the rules of life :)\n"""\n\nfrom random import choice\nfrom turtle import *\n\nfrom freegames import square\n\ncells = {}\n\n\ndef initialize():\n    """Randomly initialize the cells."""\n    for x in range(-200, 200, 10):\n        for y in range(-200, 200, 10):\n            cells[x, y] = False\n\n    for x in range(-50, 50, 10):\n        for y in range(-50, 50, 10):\n            cells[x, y] = choice([True, False])\n\n\ndef step():\n    """Compute one step in the Game of Life."""\n    neighbors = {}\n\n    for x in range(-190, 190, 10):\n        for y in range(-190, 190, 10):\n            count = -cells[x, y]\n            for h in [-10, 0, 10]:\n                for v in [-10, 0, 10]:\n                    count += cells[x + h, y + v]\n            neighbors[x, y] = count\n\n    for cell, count in neighbors.items():\n        if cells[cell]:\n            if count < 2 or count > 3:\n                cells[cell] = False\n        elif count == 3:\n            cells[cell] = True\n\n\ndef draw():\n    """Draw all the squares."""\n    step()\n    clear()\n    for (x, y), alive in cells.items():\n        color = \'green\' if alive else \'black\'\n        square(x, y, 10, color)\n    update()\n    ontimer(draw, 100)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\ninitialize()\ndraw()\ndone()\n',
          "./connect.py":
            "\"\"\"Connect Four\n\nExercises\n\n1. Change the colors.\n2. Draw squares instead of circles for open spaces.\n3. Add logic to detect a full row.\n4. Create a random computer player.\n5. How would you detect a winner?\n\"\"\"\n\nfrom turtle import *\n\nfrom freegames import line\n\nturns = {'red': 'yellow', 'yellow': 'red'}\nstate = {'player': 'yellow', 'rows': [0] * 8}\n\n\ndef grid():\n    \"\"\"Draw Connect Four grid.\"\"\"\n    bgcolor('light blue')\n\n    for x in range(-150, 200, 50):\n        line(x, -200, x, 200)\n\n    for x in range(-175, 200, 50):\n        for y in range(-175, 200, 50):\n            up()\n            goto(x, y)\n            dot(40, 'white')\n\n    update()\n\n\ndef tap(x, y):\n    \"\"\"Draw red or yellow circle in tapped row.\"\"\"\n    player = state['player']\n    rows = state['rows']\n\n    row = int((x + 200) // 50)\n    count = rows[row]\n\n    x = ((x + 200) // 50) * 50 - 200 + 25\n    y = count * 50 - 200 + 25\n\n    up()\n    goto(x, y)\n    dot(40, player)\n    update()\n\n    rows[row] = count + 1\n    state['player'] = turns[player]\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\ngrid()\nonscreenclick(tap)\ndone()\n",
          "./tiles.py":
            '"""Tiles, number swapping game.\n\nExercises\n\n1. Track a score by the number of tile moves.\n2. Permit diagonal squares as neighbors.\n3. Respond to arrow keys instead of mouse clicks.\n4. Make the grid bigger.\n"""\n\nfrom random import *\nfrom turtle import *\n\nfrom freegames import floor, vector\n\ntiles = {}\nneighbors = [\n    vector(100, 0),\n    vector(-100, 0),\n    vector(0, 100),\n    vector(0, -100),\n]\n\n\ndef load():\n    """Load tiles and scramble."""\n    count = 1\n\n    for y in range(-200, 200, 100):\n        for x in range(-200, 200, 100):\n            mark = vector(x, y)\n            tiles[mark] = count\n            count += 1\n\n    tiles[mark] = None\n\n    for count in range(1000):\n        neighbor = choice(neighbors)\n        spot = mark + neighbor\n\n        if spot in tiles:\n            number = tiles[spot]\n            tiles[spot] = None\n            tiles[mark] = number\n            mark = spot\n\n\ndef square(mark, number):\n    """Draw white square with black outline and number."""\n    up()\n    goto(mark.x, mark.y)\n    down()\n\n    color(\'black\', \'white\')\n    begin_fill()\n    for count in range(4):\n        forward(99)\n        left(90)\n    end_fill()\n\n    if number is None:\n        return\n    elif number < 10:\n        forward(20)\n\n    write(number, font=(\'Arial\', 60, \'normal\'))\n\n\ndef tap(x, y):\n    """Swap tile and empty square."""\n    x = floor(x, 100)\n    y = floor(y, 100)\n    mark = vector(x, y)\n\n    for neighbor in neighbors:\n        spot = mark + neighbor\n\n        if spot in tiles and tiles[spot] is None:\n            number = tiles[mark]\n            tiles[spot] = number\n            square(spot, number)\n            tiles[mark] = None\n            square(mark, None)\n\n\ndef draw():\n    """Draw all tiles."""\n    for mark in tiles:\n        square(mark, tiles[mark])\n    update()\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\nload()\ndraw()\nonscreenclick(tap)\ndone()\n',
          "./fidget.py":
            '"""Fidget, inspired by fidget spinners.\n\nExercises\n\n1. Change the spinner pattern.\n2. Respond to mouse clicks.\n3. Change its acceleration.\n4. Make it go forwards and backwards.\n"""\n\nfrom turtle import *\n\nstate = {\'turn\': 0}\n\n\ndef spinner():\n    """Draw fidget spinner."""\n    clear()\n    angle = state[\'turn\'] / 10\n    right(angle)\n    forward(100)\n    dot(120, \'red\')\n    back(100)\n    right(120)\n    forward(100)\n    dot(120, \'green\')\n    back(100)\n    right(120)\n    forward(100)\n    dot(120, \'blue\')\n    back(100)\n    right(120)\n    update()\n\n\ndef animate():\n    """Animate fidget spinner."""\n    if state[\'turn\'] > 0:\n        state[\'turn\'] -= 1\n\n    spinner()\n    ontimer(animate, 20)\n\n\ndef flick():\n    """Flick fidget spinner."""\n    state[\'turn\'] += 10\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\nwidth(20)\nonkey(flick, \'space\')\nlisten()\nanimate()\ndone()\n',
          "./minesweeper.py":
            '"""Minesweeper\n\nExercises\n\n1. What does the `seed(0)` function call do?\n2. Change the number of bombs on the grid.\n3. Change the size of the grid.\n"""\n\nfrom random import randrange, seed\nfrom turtle import *\n\nfrom freegames import floor, square\n\nseed(0)\nbombs = {}\nshown = {}\ncounts = {}\n\n\ndef initialize():\n    """Initialize `bombs`, `counts`, and `shown` grids."""\n    for x in range(-250, 250, 50):\n        for y in range(-250, 250, 50):\n            bombs[x, y] = False\n            shown[x, y] = False\n            counts[x, y] = -1\n\n    for count in range(8):\n        x = randrange(-200, 200, 50)\n        y = randrange(-200, 200, 50)\n        bombs[x, y] = True\n\n    for x in range(-200, 200, 50):\n        for y in range(-200, 200, 50):\n            total = 0\n            for i in (-50, 0, 50):\n                for j in (-50, 0, 50):\n                    total += bombs[x + i, y + j]\n            counts[x, y] = total\n\n\ndef stamp(x, y, text):\n    """Display `text` at coordinates `x` and `y`."""\n    square(x, y, 50, \'white\')\n    color(\'black\')\n    write(text, font=(\'Arial\', 50, \'normal\'))\n\n\ndef draw():\n    """Draw the initial board grid."""\n    for x in range(-200, 200, 50):\n        for y in range(-200, 200, 50):\n            stamp(x, y, \'?\')\n\n\ndef end():\n    """Draw the bombs as X\'s on the grid."""\n    for x in range(-200, 200, 50):\n        for y in range(-200, 200, 50):\n            if bombs[x, y]:\n                stamp(x, y, \'X\')\n\n\ndef tap(x, y):\n    """Respond to screen click at `x` and `y` coordinates."""\n    x = floor(x, 50)\n    y = floor(y, 50)\n\n    if bombs[x, y]:\n        end()\n        return\n\n    pairs = [(x, y)]\n\n    while pairs:\n        x, y = pairs.pop()\n        stamp(x, y, counts[x, y])\n        shown[x, y] = True\n\n        if counts[x, y] == 0:\n            for i in (-50, 0, 50):\n                for j in (-50, 0, 50):\n                    pair = x + i, y + j\n                    if not shown[pair]:\n                        pairs.append(pair)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\ninitialize()\ndraw()\nonscreenclick(tap)\ndone()\n',
          "./__main__.py":
            "\"\"\"Free Games CLI\n\"\"\"\n\nimport argparse\nimport os\n\ndirectory = os.path.dirname(os.path.realpath(__file__))\ncontents = os.listdir(directory)\n\n\ndef game_file(name):\n    \"\"\"Return True if filename represents a game.\"\"\"\n    return (\n        name.endswith('.py')\n        and not name.startswith('__')\n        and name != 'utils.py'\n    )\n\n\ngames = sorted(name[:-3] for name in contents if game_file(name))\n\nparser = argparse.ArgumentParser(\n    prog='freegames',\n    description='Free Python Games',\n    epilog='Copyright 2022 Grant Jenks',\n)\nsubparsers = parser.add_subparsers(dest='command', help='sub-command help')\n\nparser_list = subparsers.add_parser('list', help='list games')\n\nparser_copy = subparsers.add_parser('copy', help='copy game source code')\nparser_copy.add_argument('game', choices=games, help='game name')\nparser_copy.add_argument(\n    '--force',\n    action='store_true',\n    help='overwrite existing file',\n)\n\nparser_show = subparsers.add_parser('show', help='show game source code')\nparser_show.add_argument('game', choices=games, help='game name')\n\nargs = parser.parse_args()\n\nif args.command == 'list':\n    for game in games:\n        print(game)\nelif args.command == 'copy':\n    filename = args.game + '.py'\n\n    with open(os.path.join(directory, filename)) as reader:\n        text = reader.read()\n\n    cwd = os.getcwd()\n    path = os.path.join(cwd, filename)\n\n    if args.force or not os.path.exists(path):\n        with open(path, 'w') as writer:\n            writer.write(text)\n    else:\n        print('ERROR: File already exists. Specify --force to overwrite.')\nelse:\n    assert args.command == 'show'\n\n    with open(os.path.join(directory, args.game + '.py')) as reader:\n        print(reader.read())\n",
          "./bounce.py":
            '"""Bounce, a simple animation demo.\n\nExercises\n\n1. Make the ball speed up and down.\n2. Change how the ball bounces when it hits a wall.\n3. Make the ball leave a trail.\n4. Change the ball color based on position.\n   Hint: colormode(255); color(0, 100, 200)\n"""\n\nfrom random import *\nfrom turtle import *\n\nfrom freegames import vector\n\n\ndef value():\n    """Randomly generate value between (-5, -3) or (3, 5)."""\n    return (3 + random() * 2) * choice([1, -1])\n\n\nball = vector(0, 0)\naim = vector(value(), value())\n\n\ndef draw():\n    """Move ball and draw game."""\n    ball.move(aim)\n\n    x = ball.x\n    y = ball.y\n\n    if x < -200 or x > 200:\n        aim.x = -aim.x\n\n    if y < -200 or y > 200:\n        aim.y = -aim.y\n\n    clear()\n    goto(x, y)\n    dot(10)\n\n    ontimer(draw, 50)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\nup()\ndraw()\ndone()\n',
          "./bagels.py":
            "\"\"\"Bagels, a number puzzle game.\n\nExercises:\n\n1. Can you guess the number?\n2. How much harder is 6 digits? Do you need more guesses?\n3. What's the maximum number of digits we could support?\n\nAdapted from code in https://inventwithpython.com/chapter11.html\n\"\"\"\n\nfrom random import sample, shuffle\n\ndigits = 3\nguesses = 10\n\nprint('I am thinking of a', digits, 'digit number.')\nprint('Try to guess what it is.')\nprint('Here are some clues:')\nprint('When I say:    That means:')\nprint('  pico         One digit is correct but in the wrong position.')\nprint('  fermi        One digit is correct and in the right position.')\nprint('  bagels       No digit is correct.')\nprint('There are no repeated digits in the number.')\n\n# Create a random number.\n\nletters = sample('0123456789', digits)\n\nif letters[0] == '0':\n    letters.reverse()\n\nnumber = ''.join(letters)\n\nprint('I have thought up a number.')\nprint('You have', guesses, 'guesses to get it.')\n\ncounter = 1\n\nwhile True:\n    print('Guess #', counter)\n    guess = input()\n\n    if len(guess) != digits:\n        print('Wrong number of digits. Try again!')\n        continue\n\n    # Create the clues.\n\n    clues = []\n\n    for index in range(digits):\n        if guess[index] == number[index]:\n            clues.append('fermi')\n        elif guess[index] in number:\n            clues.append('pico')\n\n    shuffle(clues)\n\n    if len(clues) == 0:\n        print('bagels')\n    else:\n        print(' '.join(clues))\n\n    counter += 1\n\n    if guess == number:\n        print('You got it!')\n        break\n\n    if counter > guesses:\n        print('You ran out of guesses. The answer was', number)\n        break\n",
          "./crypto.py":
            "\"\"\"Crypto: tool for encrypting and decrypting messages.\n\nExercises\n\n1. Review 'ord' and 'chr' functions and letter-to-number mapping.\n2. Explain what happens if you use key 26.\n3. Find a way to decode a message without a key.\n4. Encrypt numbers.\n5. Make the encryption harder to decode.\n\nAdapted from code in https://inventwithpython.com/chapter14.html\n\"\"\"\n\n\ndef encrypt(message, key):\n    \"\"\"Encrypt message with key.\"\"\"\n    result = ''\n\n    # Iterate letters in message and encrypt each individually.\n\n    for letter in message:\n        if letter.isalpha():\n\n            # Letters are numbered like so:\n            # A, B, C - Z is 65, 66, 67 - 90\n            # a, b, c - z is 97, 98, 99 - 122\n\n            num = ord(letter)\n\n            if letter.isupper():\n                base = ord('A')\n            else:\n                assert letter.islower()\n                base = ord('a')\n\n            # The encryption equation:\n\n            num = (num - base + key) % 26 + base\n\n            result += chr(num)\n\n        elif letter.isdigit():\n\n            # TODO: Encrypt digits.\n            result += letter\n\n        else:\n            result += letter\n\n    return result\n\n\ndef decrypt(message, key):\n    \"\"\"Decrypt message with key.\"\"\"\n    return encrypt(message, -key)\n\n\ndef decode(message):\n    \"\"\"Decode message without key.\"\"\"\n    pass  # TODO\n\n\ndef get_key():\n    \"\"\"Get key from user.\"\"\"\n    try:\n        text = input('Enter a key (1 - 25): ')\n        key = int(text)\n        return key\n    except:\n        print('Invalid key. Using key: 0.')\n        return 0\n\n\nprint('Do you wish to encrypt, decrypt, or decode a message?')\nchoice = input()\n\nif choice == 'encrypt':\n    phrase = input('Message: ')\n    code = get_key()\n    print('Encrypted message:', encrypt(phrase, code))\nelif choice == 'decrypt':\n    phrase = input('Message: ')\n    code = get_key()\n    print('Decrypted message:', decrypt(phrase, code))\nelif choice == 'decode':\n    phrase = input('Message: ')\n    print('Decoding message:')\n    decode(phrase)\nelse:\n    print('Error: Unrecognized Command')\n",
          "./maze.py":
            '"""Maze, move from one side to another.\n\nExcercises\n\n1. Keep score by counting taps.\n2. Make the maze harder.\n3. Generate the same maze twice.\n"""\n\nfrom random import random\nfrom turtle import *\n\nfrom freegames import line\n\n\ndef draw():\n    """Draw maze."""\n    color(\'black\')\n    width(5)\n\n    for x in range(-200, 200, 40):\n        for y in range(-200, 200, 40):\n            if random() > 0.5:\n                line(x, y, x + 40, y + 40)\n            else:\n                line(x, y + 40, x + 40, y)\n\n    update()\n\n\ndef tap(x, y):\n    """Draw line and dot for screen tap."""\n    if abs(x) > 198 or abs(y) > 198:\n        up()\n    else:\n        down()\n\n    width(2)\n    color(\'red\')\n    goto(x, y)\n    dot(4)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\ndraw()\nonscreenclick(tap)\ndone()\n',
          "./cannon.py":
            '"""Cannon, hitting targets with projectiles.\n\nExercises\n\n1. Keep score by counting target hits.\n2. Vary the effect of gravity.\n3. Apply gravity to the targets.\n4. Change the speed of the ball.\n"""\n\nfrom random import randrange\nfrom turtle import *\n\nfrom freegames import vector\n\nball = vector(-200, -200)\nspeed = vector(0, 0)\ntargets = []\n\n\ndef tap(x, y):\n    """Respond to screen tap."""\n    if not inside(ball):\n        ball.x = -199\n        ball.y = -199\n        speed.x = (x + 200) / 25\n        speed.y = (y + 200) / 25\n\n\ndef inside(xy):\n    """Return True if xy within screen."""\n    return -200 < xy.x < 200 and -200 < xy.y < 200\n\n\ndef draw():\n    """Draw ball and targets."""\n    clear()\n\n    for target in targets:\n        goto(target.x, target.y)\n        dot(20, \'blue\')\n\n    if inside(ball):\n        goto(ball.x, ball.y)\n        dot(6, \'red\')\n\n    update()\n\n\ndef move():\n    """Move ball and targets."""\n    if randrange(40) == 0:\n        y = randrange(-150, 150)\n        target = vector(200, y)\n        targets.append(target)\n\n    for target in targets:\n        target.x -= 0.5\n\n    if inside(ball):\n        speed.y -= 0.35\n        ball.move(speed)\n\n    dupe = targets.copy()\n    targets.clear()\n\n    for target in dupe:\n        if abs(target - ball) > 13:\n            targets.append(target)\n\n    draw()\n\n    for target in targets:\n        if not inside(target):\n            return\n\n    ontimer(move, 50)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\nup()\ntracer(False)\nonscreenclick(tap)\nmove()\ndone()\n',
          "./snake.py":
            '"""Snake, classic arcade game.\n\nExercises\n\n1. How do you make the snake faster or slower?\n2. How can you make the snake go around the edges?\n3. How would you move the food?\n4. Change the snake to respond to mouse clicks.\n"""\n\nfrom random import randrange\nfrom turtle import *\n\nfrom freegames import square, vector\n\nfood = vector(0, 0)\nsnake = [vector(10, 0)]\naim = vector(0, -10)\n\n\ndef change(x, y):\n    """Change snake direction."""\n    aim.x = x\n    aim.y = y\n\n\ndef inside(head):\n    """Return True if head inside boundaries."""\n    return -200 < head.x < 190 and -200 < head.y < 190\n\n\ndef move():\n    """Move snake forward one segment."""\n    head = snake[-1].copy()\n    head.move(aim)\n\n    if not inside(head) or head in snake:\n        square(head.x, head.y, 9, \'red\')\n        update()\n        return\n\n    snake.append(head)\n\n    if head == food:\n        print(\'Snake:\', len(snake))\n        food.x = randrange(-15, 15) * 10\n        food.y = randrange(-15, 15) * 10\n    else:\n        snake.pop(0)\n\n    clear()\n\n    for body in snake:\n        square(body.x, body.y, 9, \'black\')\n\n    square(food.x, food.y, 9, \'green\')\n    update()\n    ontimer(move, 100)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\nlisten()\nonkey(lambda: change(10, 0), \'Right\')\nonkey(lambda: change(-10, 0), \'Left\')\nonkey(lambda: change(0, 10), \'Up\')\nonkey(lambda: change(0, -10), \'Down\')\nmove()\ndone()\n',
          "./flappy.py":
            '"""Flappy, game inspired by Flappy Bird.\n\nExercises\n\n1. Keep score.\n2. Vary the speed.\n3. Vary the size of the balls.\n4. Allow the bird to move forward and back.\n"""\n\nfrom random import *\nfrom turtle import *\n\nfrom freegames import vector\n\nbird = vector(0, 0)\nballs = []\n\n\ndef tap(x, y):\n    """Move bird up in response to screen tap."""\n    up = vector(0, 30)\n    bird.move(up)\n\n\ndef inside(point):\n    """Return True if point on screen."""\n    return -200 < point.x < 200 and -200 < point.y < 200\n\n\ndef draw(alive):\n    """Draw screen objects."""\n    clear()\n\n    goto(bird.x, bird.y)\n\n    if alive:\n        dot(10, \'green\')\n    else:\n        dot(10, \'red\')\n\n    for ball in balls:\n        goto(ball.x, ball.y)\n        dot(20, \'black\')\n\n    update()\n\n\ndef move():\n    """Update object positions."""\n    bird.y -= 5\n\n    for ball in balls:\n        ball.x -= 3\n\n    if randrange(10) == 0:\n        y = randrange(-199, 199)\n        ball = vector(199, y)\n        balls.append(ball)\n\n    while len(balls) > 0 and not inside(balls[0]):\n        balls.pop(0)\n\n    if not inside(bird):\n        draw(False)\n        return\n\n    for ball in balls:\n        if abs(ball - bird) < 15:\n            draw(False)\n            return\n\n    draw(True)\n    ontimer(move, 50)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\nup()\ntracer(False)\nonscreenclick(tap)\nmove()\ndone()\n',
          "./memory.py":
            '"""Memory, puzzle game of number pairs.\n\nExercises:\n\n1. Count and print how many taps occur.\n2. Decrease the number of tiles to a 4x4 grid.\n3. Detect when all tiles are revealed.\n4. Center single-digit tile.\n5. Use letters instead of tiles.\n"""\n\nfrom random import *\nfrom turtle import *\n\nfrom freegames import path\n\ncar = path(\'car.gif\')\ntiles = list(range(32)) * 2\nstate = {\'mark\': None}\nhide = [True] * 64\n\n\ndef square(x, y):\n    """Draw white square with black outline at (x, y)."""\n    up()\n    goto(x, y)\n    down()\n    color(\'black\', \'white\')\n    begin_fill()\n    for count in range(4):\n        forward(50)\n        left(90)\n    end_fill()\n\n\ndef index(x, y):\n    """Convert (x, y) coordinates to tiles index."""\n    return int((x + 200) // 50 + ((y + 200) // 50) * 8)\n\n\ndef xy(count):\n    """Convert tiles count to (x, y) coordinates."""\n    return (count % 8) * 50 - 200, (count // 8) * 50 - 200\n\n\ndef tap(x, y):\n    """Update mark and hidden tiles based on tap."""\n    spot = index(x, y)\n    mark = state[\'mark\']\n\n    if mark is None or mark == spot or tiles[mark] != tiles[spot]:\n        state[\'mark\'] = spot\n    else:\n        hide[spot] = False\n        hide[mark] = False\n        state[\'mark\'] = None\n\n\ndef draw():\n    """Draw image and tiles."""\n    clear()\n    goto(0, 0)\n    shape(car)\n    stamp()\n\n    for count in range(64):\n        if hide[count]:\n            x, y = xy(count)\n            square(x, y)\n\n    mark = state[\'mark\']\n\n    if mark is not None and hide[mark]:\n        x, y = xy(mark)\n        up()\n        goto(x + 2, y)\n        color(\'black\')\n        write(tiles[mark], font=(\'Arial\', 30, \'normal\'))\n\n    update()\n    ontimer(draw, 100)\n\n\nshuffle(tiles)\nsetup(420, 420, 370, 0)\naddshape(car)\nhideturtle()\ntracer(False)\nonscreenclick(tap)\ndraw()\ndone()\n',
          "./ant.py":
            '"""Ant, simple animation demo.\n\nExercises\n\n1. Wrap ant around screen boundaries.\n2. Make the ant leave a trail.\n3. Change the ant color based on position.\n   Hint: colormode(255); color(0, 100, 200)\n"""\n\nfrom random import *\nfrom turtle import *\n\nfrom freegames import vector\n\nant = vector(0, 0)\naim = vector(2, 0)\n\n\ndef wrap(value):\n    """Wrap value around -200 and 200."""\n    return value  # TODO\n\n\ndef draw():\n    """Move ant and draw screen."""\n    ant.move(aim)\n    ant.x = wrap(ant.x)\n    ant.y = wrap(ant.y)\n\n    aim.move(random() - 0.5)\n    aim.rotate(random() * 10 - 5)\n\n    clear()\n    goto(ant.x, ant.y)\n    dot(4)\n\n    ontimer(draw, 100)\n\n\nsetup(420, 420, 370, 0)\nhideturtle()\ntracer(False)\nup()\ndraw()\ndone()\n'
        }
      }

      setLoading(false)
    })()
  }, [])

  function interruptExecution() {}

  async function runCode(code: string) {
    setCodeRunning(true)

    const myPromise = Sk.misceval.asyncToPromise(function () {
      return Sk.importMainWithBody("<stdin>", false, code, true)
    })

    myPromise.then(
      function (mod: any) {
        setCodeRunning(false)
      },
      function (err: any) {
        onError(err.toString())
        setCodeRunning(false)
      }
    )
  }

  return {
    interruptExecution,
    runCode
  }
}
